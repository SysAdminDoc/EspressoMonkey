// CodeMirror Lint Addon
// Provides linting infrastructure for CodeMirror
(function(mod) {
  if (typeof exports == "object" && typeof module == "object")
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd)
    define(["../../lib/codemirror"], mod);
  else
    mod(CodeMirror);
})(function(CodeMirror) {
  "use strict";

  var GUTTER_ID = "CodeMirror-lint-markers";

  // Show tooltip with lint messages
  function showTooltip(cm, e, content) {
    var tt = document.createElement("div");
    tt.className = "CodeMirror-lint-tooltip";
    tt.appendChild(content.cloneNode(true));
    
    if (cm.state.lint.options.selfContain) {
      cm.getWrapperElement().appendChild(tt);
    } else {
      document.body.appendChild(tt);
    }

    function position(e) {
      var rect = cm.getWrapperElement().getBoundingClientRect();
      var x = e.clientX, y = e.clientY;
      
      tt.style.left = (x + 10) + "px";
      tt.style.top = (y + 10) + "px";
      
      // Ensure tooltip stays within viewport
      var ttRect = tt.getBoundingClientRect();
      if (ttRect.right > window.innerWidth) {
        tt.style.left = (window.innerWidth - ttRect.width - 10) + "px";
      }
      if (ttRect.bottom > window.innerHeight) {
        tt.style.top = (y - ttRect.height - 10) + "px";
      }
    }
    position(e);
    
    // Fade in
    setTimeout(function() { tt.classList.add("CodeMirror-lint-tooltip-visible"); }, 10);
    
    return tt;
  }

  function hideTooltip(tt) {
    if (!tt) return;
    tt.classList.remove("CodeMirror-lint-tooltip-visible");
    setTimeout(function() {
      if (tt.parentNode) tt.parentNode.removeChild(tt);
    }, 200);
  }

  function showTooltipFor(cm, e, content, node) {
    var tooltip = showTooltip(cm, e, content);
    function hide() {
      CodeMirror.off(node, "mouseout", hide);
      CodeMirror.off(node, "click", hide);
      hideTooltip(tooltip);
    }
    CodeMirror.on(node, "mouseout", hide);
    CodeMirror.on(node, "click", hide);
  }

  function LintState(cm, options, hasGutter) {
    this.marked = [];
    this.options = options;
    this.timeout = null;
    this.hasGutter = hasGutter;
    this.onMouseOver = function(e) { onMouseOver(cm, e); };
    this.waitingFor = 0;
  }

  function parseOptions(cm, options) {
    if (options instanceof Function) return {getAnnotations: options};
    if (!options || options === true) options = {};
    return options;
  }

  function clearMarks(cm) {
    var state = cm.state.lint;
    if (state.hasGutter) cm.clearGutter(GUTTER_ID);
    if (state.options.highlightLines) clearLineHighlights(cm);
    for (var i = 0; i < state.marked.length; ++i)
      state.marked[i].clear();
    state.marked.length = 0;
  }

  function clearLineHighlights(cm) {
    cm.eachLine(function(line) {
      var lineNo = cm.getLineNumber(line);
      cm.removeLineClass(lineNo, "wrap", "CodeMirror-lint-line-error");
      cm.removeLineClass(lineNo, "wrap", "CodeMirror-lint-line-warning");
    });
  }

  function makeMarker(cm, labels, severity, multiple, tooltips) {
    var marker = document.createElement("div");
    var inner = marker;

    marker.className = "CodeMirror-lint-marker CodeMirror-lint-marker-" + severity;
    if (multiple) {
      inner = marker.appendChild(document.createElement("div"));
      inner.className = "CodeMirror-lint-marker CodeMirror-lint-marker-multiple";
    }

    if (tooltips !== false) {
      CodeMirror.on(marker, "mouseover", function(e) {
        showTooltipFor(cm, e, labels, marker);
      });
    }

    return marker;
  }

  function getMaxSeverity(a, b) {
    if (a === "error") return a;
    else return b;
  }

  function groupByLine(annotations) {
    var lines = [];
    for (var i = 0; i < annotations.length; ++i) {
      var ann = annotations[i], line = ann.from.line;
      (lines[line] || (lines[line] = [])).push(ann);
    }
    return lines;
  }

  function annotationTooltip(ann) {
    var severity = ann.severity || "error";
    var tip = document.createElement("div");
    tip.className = "CodeMirror-lint-message CodeMirror-lint-message-" + severity;
    if (typeof ann.messageHTML !== "undefined") {
      tip.innerHTML = ann.messageHTML;
    } else {
      tip.appendChild(document.createTextNode(ann.message));
    }
    return tip;
  }

  function lintAsync(cm, getAnnotations) {
    var state = cm.state.lint;
    var id = ++state.waitingFor;

    function abort() {
      id = -1;
      cm.off("change", abort);
    }
    cm.on("change", abort);

    getAnnotations(cm.getValue(), function(annotations, arg2) {
      cm.off("change", abort);
      if (state.waitingFor !== id) return;
      if (arg2 && annotations instanceof CodeMirror) annotations = arg2;
      cm.operation(function() { updateLinting(cm, annotations); });
    }, state.options, cm);
  }

  function startLinting(cm) {
    var state = cm.state.lint;
    if (!state) return;
    var options = state.options;
    
    var getAnnotations = options.getAnnotations || cm.getHelper(CodeMirror.Pos(0, 0), "lint");
    if (!getAnnotations) return;

    if (options.async || getAnnotations.async) {
      lintAsync(cm, getAnnotations);
    } else {
      var annotations = getAnnotations(cm.getValue(), options, cm);
      if (!annotations) return;
      if (annotations.then) {
        annotations.then(function(anns) {
          cm.operation(function() { updateLinting(cm, anns); });
        });
      } else {
        cm.operation(function() { updateLinting(cm, annotations); });
      }
    }
  }

  function updateLinting(cm, annotations) {
    var state = cm.state.lint;
    if (!state) return;
    
    clearMarks(cm);
    
    var options = state.options;
    var lines = groupByLine(annotations);

    for (var line = 0; line < lines.length; ++line) {
      var anns = lines[line];
      if (!anns) continue;

      var maxSeverity = null;
      var tipLabel = document.createElement("div");

      for (var i = 0; i < anns.length; ++i) {
        var ann = anns[i];
        var severity = ann.severity || "error";
        maxSeverity = getMaxSeverity(maxSeverity, severity);

        tipLabel.appendChild(annotationTooltip(ann));

        if (ann.to) {
          state.marked.push(cm.markText(ann.from, ann.to, {
            className: "cm-lint-" + severity,
            __annotation: ann
          }));
        }
      }

      if (state.hasGutter) {
        var marker = makeMarker(cm, tipLabel, maxSeverity, anns.length > 1, options.tooltips);
        cm.setGutterMarker(line, GUTTER_ID, marker);
      }

      if (options.highlightLines) {
        cm.addLineClass(line, "wrap", "CodeMirror-lint-line-" + maxSeverity);
      }
    }

    if (options.onUpdateLinting) {
      options.onUpdateLinting(annotations, annotations, cm);
    }
  }

  function onChange(cm) {
    var state = cm.state.lint;
    if (!state) return;
    clearTimeout(state.timeout);
    state.timeout = setTimeout(function() { startLinting(cm); }, state.options.delay || 500);
  }

  function onMouseOver(cm, e) {
    var target = e.target || e.srcElement;
    
    // Check for gutter markers
    if (!/\bCodeMirror-lint-marker\b/.test(target.className)) return;
    
    var box = target.getBoundingClientRect();
    var x = (box.left + box.right) / 2;
    var y = (box.top + box.bottom) / 2;
    var pos = cm.coordsChar({left: x, top: y}, "client");

    var spans = cm.findMarksAt(pos);
    for (var i = 0; i < spans.length; ++i) {
      var ann = spans[i].__annotation;
      if (ann) {
        var tipLabel = document.createElement("div");
        tipLabel.appendChild(annotationTooltip(ann));
        showTooltipFor(cm, e, tipLabel, target);
        return;
      }
    }
  }

  CodeMirror.defineOption("lint", false, function(cm, val, old) {
    if (old && old !== CodeMirror.Init) {
      clearMarks(cm);
      if (cm.state.lint.options.lintOnChange !== false)
        cm.off("change", onChange);
      CodeMirror.off(cm.getWrapperElement(), "mouseover", cm.state.lint.onMouseOver);
      clearTimeout(cm.state.lint.timeout);
      delete cm.state.lint;
    }

    if (val) {
      var gutters = cm.getOption("gutters"), hasLintGutter = false;
      for (var i = 0; i < gutters.length; ++i)
        if (gutters[i] === GUTTER_ID) hasLintGutter = true;
      
      var state = cm.state.lint = new LintState(cm, parseOptions(cm, val), hasLintGutter);
      
      if (state.options.lintOnChange !== false)
        cm.on("change", onChange);
      
      CodeMirror.on(cm.getWrapperElement(), "mouseover", state.onMouseOver);

      startLinting(cm);
    }
  });

  CodeMirror.defineExtension("performLint", function() {
    startLinting(this);
  });
});
